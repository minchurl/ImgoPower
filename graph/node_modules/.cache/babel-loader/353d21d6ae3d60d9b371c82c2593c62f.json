{"ast":null,"code":"import uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport { scaleLinear, scalePoint, scaleBand, scaleUtc, scaleTime, scaleLog, scaleSymlog } from 'd3-scale';\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar timePrecisions = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = {\n  millisecond: [],\n  second: precisionCutOffs.slice(0, 1),\n  minute: precisionCutOffs.slice(0, 2),\n  hour: precisionCutOffs.slice(0, 3),\n  day: precisionCutOffs.slice(0, 4),\n  month: precisionCutOffs.slice(0, 5),\n  year: precisionCutOffs.slice(0, 6)\n};\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  return function (value) {\n    if (value === undefined) {\n      return value;\n    }\n\n    if (format === 'native' || value instanceof Date) {\n      return precisionFn(value);\n    }\n\n    var parseTime = useUTC ? utcParse(format) : timeParse(format);\n    return precisionFn(parseTime(value));\n  };\n};\n\nvar createLinearScale = function createLinearScale(_ref, data, size, axis) {\n  var _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === void 0 ? false : _ref$clamp,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var minValue;\n\n  if (min === 'auto') {\n    var _data$minStacked;\n\n    minValue = stacked === true ? (_data$minStacked = data.minStacked) !== null && _data$minStacked !== void 0 ? _data$minStacked : 0 : data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    var _data$maxStacked;\n\n    maxValue = stacked === true ? (_data$maxStacked = data.maxStacked) !== null && _data$maxStacked !== void 0 ? _data$maxStacked : 0 : data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]).domain(reverse ? [maxValue, minValue] : [minValue, maxValue]).clamp(clamp);\n  if (nice === true) scale.nice();else if (typeof nice === 'number') scale.nice(nice);\n  var typedScale = scale;\n  typedScale.type = 'linear';\n  typedScale.stacked = stacked;\n  return typedScale;\n};\n\nvar createPointScale = function createPointScale(_spec, data, size) {\n  var scale = scalePoint().range([0, size]).domain(data.all);\n  var typedScale = scale;\n  typedScale.type = 'point';\n  return typedScale;\n};\n\nvar createBandScale = function createBandScale(_ref, data, size, axis) {\n  var _ref$round = _ref.round,\n      round = _ref$round === void 0 ? true : _ref$round;\n  var scale = scaleBand().range(axis === 'x' ? [0, size] : [size, 0]).domain(data.all).round(round);\n  var typedScale = scale;\n  typedScale.type = 'band';\n  return typedScale;\n};\n\nvar createTimeScale = function createTimeScale(_ref, data, size) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = normalize(data.min);\n  } else if (format !== 'native') {\n    minValue = normalize(min);\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = normalize(data.max);\n  } else if (format !== 'native') {\n    maxValue = normalize(max);\n  } else {\n    maxValue = max;\n  }\n\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.range([0, size]);\n  if (minValue && maxValue) scale.domain([minValue, maxValue]);\n  if (nice === true) scale.nice();else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice);\n  var typedScale = scale;\n  typedScale.type = 'time';\n  typedScale.useUTC = useUTC;\n  return typedScale;\n};\n\nvar createLogScale = function createLogScale(_ref, data, size, axis) {\n  var _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var hasZero = data.all.some(function (v) {\n    return v === 0;\n  });\n\n  if (hasZero) {\n    throw new Error(\"a log scale domain must not include or cross zero\");\n  }\n\n  var sign;\n  var hasMixedSign = false;\n  data.all.filter(function (v) {\n    return v != null;\n  }).forEach(function (v) {\n    if (hasMixedSign) return;\n\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n\n  if (hasMixedSign) {\n    throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n  }\n\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  var typedScale = scale;\n  typedScale.type = 'log';\n  return scale;\n};\n\nvar createSymlogScale = function createSymlogScale(_ref, data, size, axis) {\n  var _ref$constant = _ref.constant,\n      constant = _ref$constant === void 0 ? 1 : _ref$constant,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var minValue;\n\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n\n  var maxValue;\n\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n\n  var scale = scaleSymlog().constant(constant).rangeRound(axis === 'x' ? [0, size] : [size, 0]).nice();\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  var typedScale = scale;\n  typedScale.type = 'symlog';\n  return typedScale;\n};\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nfunction computeScale(spec, data, size, axis) {\n  switch (spec.type) {\n    case 'linear':\n      return createLinearScale(spec, data, size, axis);\n\n    case 'point':\n      return createPointScale(spec, data, size);\n\n    case 'band':\n      return createBandScale(spec, data, size, axis);\n\n    case 'time':\n      return createTimeScale(spec, data, size);\n\n    case 'log':\n      return createLogScale(spec, data, size, axis);\n\n    case 'symlog':\n      return createSymlogScale(spec, data, size, axis);\n\n    default:\n      throw new Error('invalid scale spec');\n  }\n}\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _objectSpread2(_objectSpread2({}, serie), {}, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _objectSpread2({}, d)\n        };\n      })\n    });\n  });\n\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n\n  if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n    stackX(xy, series);\n  }\n\n  if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n    stackY(xy, series);\n  }\n\n  var xScale = computeScale(xScaleSpec, xy.x, width, 'x');\n  var yScale = computeScale(yScaleSpec, xy.y, height, 'y');\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      var _xScale, _yScale;\n\n      d.position = {\n        x: 'stacked' in xScale && xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : (_xScale = xScale(d.data.x)) !== null && _xScale !== void 0 ? _xScale : null,\n        y: 'stacked' in yScale && yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : (_yScale = yScale(d.data.y)) !== null && _yScale !== void 0 ? _yScale : null\n      };\n    });\n  });\n  return _objectSpread2(_objectSpread2({}, xy), {}, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n\n        if (value) {\n          setValue(d, parseFloat(String(value)));\n        }\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n\n        if (value) {\n          setValue(d, parseTime(value));\n        }\n      });\n    });\n  }\n\n  var values = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      values.push(getValue(d));\n    });\n  });\n\n  switch (scaleSpec.type) {\n    case 'linear':\n      {\n        var all = sortBy(uniq(values), function (v) {\n          return v;\n        });\n        return {\n          all: all,\n          min: Math.min.apply(Math, _toConsumableArray(all)),\n          max: Math.max.apply(Math, _toConsumableArray(all))\n        };\n      }\n\n    case 'time':\n      {\n        var _all = uniqBy(values, function (v) {\n          return v.getTime();\n        }).slice(0).sort(function (a, b) {\n          return b.getTime() - a.getTime();\n        }).reverse();\n\n        return {\n          all: _all,\n          min: _all[0],\n          max: last(_all)\n        };\n      }\n\n    default:\n      {\n        var _all2 = uniq(values);\n\n        return {\n          all: _all2,\n          min: _all2[0],\n          max: last(_all2)\n        };\n      }\n  }\n};\n\nvar stackAxis = function stackAxis(axis, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[\"\".concat(axis, \"Stacked\")] = stackValue;\n      }\n\n      stack.push(stackValue);\n\n      if (stackValue !== null) {\n        all.push(stackValue);\n      }\n    });\n  });\n  xy[axis].minStacked = Math.min.apply(Math, all);\n  xy[axis].maxStacked = Math.max.apply(Math, all);\n};\n\nvar stackX = function stackX(xy, series) {\n  return stackAxis('x', xy, series);\n};\n\nvar stackY = function stackY(xy, series) {\n  return stackAxis('y', xy, series);\n};\n\nexport { compareDateValues, compareValues, computeScale, computeXYScalesForSeries, createBandScale, createDateNormalizer, createLinearScale, createLogScale, createPointScale, createPrecisionMethod, createSymlogScale, createTimeScale, generateSeriesAxis, generateSeriesXY, getOtherAxis, precisionCutOffs, precisionCutOffsByType, stackAxis, timePrecisions };","map":{"version":3,"sources":["../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts"],"names":["arrayLikeToArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","defineProperty","timePrecisions","precisionCutOffs","date","precisionCutOffsByType","millisecond","second","minute","hour","day","month","year","createPrecisionMethod","cutOff","createDateNormalizer","format","precision","useUTC","precisionFn","value","parseTime","utcParse","timeParse","createLinearScale","min","max","stacked","reverse","clamp","nice","minValue","data","maxValue","scale","scaleLinear","axis","typedScale","createPointScale","scalePoint","createBandScale","round","scaleBand","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","base","hasZero","v","hasMixedSign","sign","Math","scaleLog","createSymlogScale","constant","scaleSymlog","getOtherAxis","compareValues","a","compareDateValues","b","spec","computeXYScalesForSeries","series","xy","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","computeScale","yScale","serie","d","x","y","generateSeriesAxis","getValue","setValue","scaleSpec","parseFloat","String","values","all","sortBy","uniq","last","stackAxis","otherAxis","compare","isDate","stack","datum","stackValue","head"],"mappings":"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","sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, Series, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ntype InputXYSeries = Record<'x' | 'y', number | string | Date | null>\n\ninterface Data {\n    x: number\n    xStacked: number | null\n    y: number\n    yStacked: number | null\n\n    // Allow template literal `xStacked/yStacked` to be set on line 213\n    [key: string]: number | null\n}\n\ntype XYSeries = InputXYSeries & {\n    data: Data[]\n}\n\ninterface ComputedXYSeries extends InputXYSeries {\n    data: Array<{\n        data: Data\n        position: {\n            x: ScaleValue | null\n            y: ScaleValue | null\n        }\n    }>\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\nexport const computeXYScalesForSeries = (\n    _series: XYSeries[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    })) as ComputedXYSeries[]\n\n    const xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX(xy as StackedXY, series)\n    }\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY(xy as StackedXY, series)\n    }\n\n    const xScale = computeScale(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale(yScaleSpec, xy.y, height, 'y')\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    'stacked' in xScale && xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x) ?? null,\n                y:\n                    'stacked' in yScale && yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y) ?? null,\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <XValue extends ScaleValue, YValue extends ScaleValue>(\n    series: Series<XValue, YValue>,\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', XValue>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', YValue>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseFloat(String(value)) as unknown) as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseTime(value as Date) as unknown) as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(uniq(values as number[]), v => v)\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = (axis: ScaleAxis, xy: StackedXY, series: ComputedXYSeries[]) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = (xy: StackedXY, series: ComputedXYSeries[]) => stackAxis('x', xy, series)\nconst stackY = (xy: StackedXY, series: ComputedXYSeries[]) => stackAxis('y', xy, series)\n"]},"metadata":{},"sourceType":"module"}